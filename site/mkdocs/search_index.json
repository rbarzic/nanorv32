{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the NanoRv32  project\n\n\nUnder construction\n\n\nA small 32-bit implementation of the RISC-V architecture\nHighlights :\n\n\n\n\n2-stage pipeline (fetch, execute)\n\n\nlot of code is generated from a high level description\n\n\nwritten in verilog (using iverilog or Xilinx xvsim as simulator)\n\n\n\n\nStill under development :\n  - currently supporting only RV32I base instructions (no scall,sbreak,rd*)\n  - no system register implemented\n  - No interrupt support yet\n  - no RVC support (16-bit instructions)\n\n\nFPGA version available (Digilent ARTY board - Xilinx Artix7)\n\n\nProject layout\n\n\ncommon/files  # scripts to generate list of verilog files needed for the various targets (simulation, synthesis)\ncommon/generators # generator for some verilog constructs (like decoder, parameters,...)\ncommon/include    # C/asm include files (for riscv-tests for example)\ncommon/instructions # text files listing instructions, for regression testing\ncommon/linker_scripts # linker script(s) for C and asm programs\ncommon/makefile # shared Makefile\ncommon/scripts  # Miscelaneous scripts\ncommon/spec # architecture/instruction specification as Python data structures\ncommon/startup # C/asm startup file\nctests/* # Various tests written in C\ndoc_riscv # General Riscv documentation from Internet (when Internet is not available :-) )\ndocs # mkdocs source files (this documentation !) see (www.mkdocs.org)\ngenerated # various generated files from generators\nriscv-opcodes # imported github module, used to create some spec files\nriscv-test    # imported github module, various test programs for the riscv architecture\nrtl/cores     # the nanorv32 CPU files\nrtl/ips       # \"IP\" verilog models (memory, peripherals, bus interfaces,....)\nrtl/chips     # top-level and \"chip\" specific files\nsim           # directory containing the simulation launcher\nsynt/fpga     # main directory for FPGA synthesis using Xilinx Vivado\n\n\n\nInstallation\n\n\nCloning from github\n\n\nThis project uses submodules. To clone it you need to run the following commands :\n\n\ngit clone git@github.com:rbarzic/nanorv32.git\ncd nanorv32\ngit submodule update --init\n\n\n\n\nDependencies\n\n\nOn debian/Unbuntu :\n\n\nsudo apt-get install build-essential gtkwave\n\n\n\n\nIcarus verilog\n\n\nUsing  the latest version from github is recommended.\n\n\nSee https://github.com/steveicarus/iverilog\n\n\nRiscv32 gcc\n\n\nA 32-bit version of the toolchain is needed.\n\n\nTo build such a toolchain, please follws the instruction provided by the PicoRV32 project on github :\n\n\nhttps://github.com/cliffordwolf/picorv32#building-a-pure-rv32i-toolchain\n\n\nOthers\n\n\nTo run the regression on multiple cores at a time, you need GNU parallel.\n\n\nOn debian/Unbuntu :\n\n\nsudo apt-get install parallel\n\n\n\n\nSimulation  using Icarus iverilog\n\n\nRunning a test written in C\n\n\nC-based tests are located under the \n/ctests directory.\nEach test consists in one or several C files together with a configuration file \noptions.py\n.\n\n\nC compilation, RTL database compilation and simulation can be launched with the Python script \nruntest.py\n under the \n/sim directory\n\n\nUnder sim :\n\n\n#./runtest.py  \npath to test directory\n\n# Example :\n./runtest.py  ../ctests/gpio_toggle\n\n\n\n\n\nThe result should be\n\n\n[OK]      gcc_compile\n[OK]      icarus_rtl_build\n[OK]      icarus_rtl_elab\n[OK]      icarus_rtl_sim\n\n\n\n\n\nTo see the commands used during the C compilation, the Verilog compilation and the simulation, add the option \n-v\n to the previous command line.\n\n\nViewing the waveform\n\n\nFirst, the simulation must be launched with the -l option to turn-on the logging of all signals to a vcd file :\n\n\n# Example :\n./runtest.py  -v -l ../ctests/gpio_toggle\n\n\n\n\n\nThen  using gtkwave, you can open the vcd file that has been created in the directory of the test\n\n\ntkwave ../ctests/gpio_toggle/tb_nanorv32.vcd \n\n\n\n\n\nSynthesis using Vivado\n\n\nFirst, set-up Vivado environment :\n\n\nsource /opt/Xilinx/Vivado/\nvivado version\n/settings64.sh\n\n\n\n\nThen, in the \n/synt/fpga directory, type :\n\n\nmake synt\n\n\n\n\nNote : The code is loaded in the ROM using the file\nsynt/fpga/code.hex. So if you want to have a specific program preloaded, you must make a link between an existing *.hex2 file to the code.hex before launching the synthesis.\n\n\nImportant note : The reset pin in mapped to the SW0 switc on the ARTY7 board. The switch must be in the position toward the board center for the reset to be released.\n\n\nUploading code using the JTAG port\n\n\nThe Nanorv32 project includes a JTAG interface (implemented using the adv_debug_sys project) that allows new CPU code to be uploaded into the FPGA without the need of a new synthesis.\n\n\nA python script for uploading code using a FT232H-based USB-to-JTAG converter is provided under \n/jtag.\n\n\nJTAG pin mapping for the Arty7 board\n\n\nThe JTAG pins are mapped on the JB connector (TCK is a special clock pin)\n\n\n\n\n\n\n\n\nPin\n\n\nFPGA pin\n\n\nArty7 JB pin name\n\n\nArty7 JB pin number\n\n\nFT232H pin\n\n\n\n\n\n\n\n\n\n\nTMS\n\n\nE15\n\n\nP1\n\n\n1\n\n\nAD3 (16)\n\n\n\n\n\n\nTDI\n\n\nE16\n\n\nP2\n\n\n2\n\n\nAD1 (14)\n\n\n\n\n\n\nTCK\n\n\nD15\n\n\nP3\n\n\n3\n\n\nAD0 (13)\n\n\n\n\n\n\nTDO\n\n\nC15\n\n\nP3\n\n\n4\n\n\nAD2 (15)\n\n\n\n\n\n\n\n\n(P5 is GND and P6 is VCC on the JB 2x6 PMOD connector)\n\n\nC Code compilation\n\n\nThe compilation of the C code to be uploaded is done using the same python script (runtest.py) as for the simulation.\nThe \n.c\n option must be used if you want to  prevent   the RTL database compilation and simulation.\n\n\n# For example (while under \ntop\n/sim) :\n./runtest.py -c -v ../ctests/gpio_toggle_infinite\n\n\n\n\nA Intel hex file is created under the test directory test\n\n\nCode upload\n\n\nThe Intel hex file can be uploaded using the following command :\n\n\n# Example (while under \ntop\n/sim) :\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/gpio_toggle_infinite/gpio_toggle_infinite.ihex -r\n\n\n\n\nThe \n-r\n option is used to force a reset after the code upload so that the CPU can start executing the code right away\n\n\nThe pyftdi and intelhex Python modules  may need to be installed for the comman above to work properly :\n\n\nsudo pip install pyftdi intelhex\n\n\n\n\nSimulation  using Vivado (outdated)\n\n\nCompilation\n\n\nmake xcomp\nmake xelab\n\n\n\n\nSimulation (Batch mode)\n\n\nmake xsim\n\n\n\n\nSimulation (GUI)\n\n\nmake xsim_gui\n\n\n\n\nSimulation  using Verilator\n\n\nTBD", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-nanorv32-project", 
            "text": "Under construction  A small 32-bit implementation of the RISC-V architecture\nHighlights :   2-stage pipeline (fetch, execute)  lot of code is generated from a high level description  written in verilog (using iverilog or Xilinx xvsim as simulator)   Still under development :\n  - currently supporting only RV32I base instructions (no scall,sbreak,rd*)\n  - no system register implemented\n  - No interrupt support yet\n  - no RVC support (16-bit instructions)  FPGA version available (Digilent ARTY board - Xilinx Artix7)", 
            "title": "Welcome to the NanoRv32  project"
        }, 
        {
            "location": "/#project-layout", 
            "text": "common/files  # scripts to generate list of verilog files needed for the various targets (simulation, synthesis)\ncommon/generators # generator for some verilog constructs (like decoder, parameters,...)\ncommon/include    # C/asm include files (for riscv-tests for example)\ncommon/instructions # text files listing instructions, for regression testing\ncommon/linker_scripts # linker script(s) for C and asm programs\ncommon/makefile # shared Makefile\ncommon/scripts  # Miscelaneous scripts\ncommon/spec # architecture/instruction specification as Python data structures\ncommon/startup # C/asm startup file\nctests/* # Various tests written in C\ndoc_riscv # General Riscv documentation from Internet (when Internet is not available :-) )\ndocs # mkdocs source files (this documentation !) see (www.mkdocs.org)\ngenerated # various generated files from generators\nriscv-opcodes # imported github module, used to create some spec files\nriscv-test    # imported github module, various test programs for the riscv architecture\nrtl/cores     # the nanorv32 CPU files\nrtl/ips       # \"IP\" verilog models (memory, peripherals, bus interfaces,....)\nrtl/chips     # top-level and \"chip\" specific files\nsim           # directory containing the simulation launcher\nsynt/fpga     # main directory for FPGA synthesis using Xilinx Vivado", 
            "title": "Project layout"
        }, 
        {
            "location": "/#installation", 
            "text": "Cloning from github  This project uses submodules. To clone it you need to run the following commands :  git clone git@github.com:rbarzic/nanorv32.git\ncd nanorv32\ngit submodule update --init  Dependencies  On debian/Unbuntu :  sudo apt-get install build-essential gtkwave  Icarus verilog  Using  the latest version from github is recommended.  See https://github.com/steveicarus/iverilog  Riscv32 gcc  A 32-bit version of the toolchain is needed.  To build such a toolchain, please follws the instruction provided by the PicoRV32 project on github :  https://github.com/cliffordwolf/picorv32#building-a-pure-rv32i-toolchain  Others  To run the regression on multiple cores at a time, you need GNU parallel.  On debian/Unbuntu :  sudo apt-get install parallel", 
            "title": "Installation"
        }, 
        {
            "location": "/#simulation-using-icarus-iverilog", 
            "text": "Running a test written in C  C-based tests are located under the  /ctests directory.\nEach test consists in one or several C files together with a configuration file  options.py .  C compilation, RTL database compilation and simulation can be launched with the Python script  runtest.py  under the  /sim directory  Under sim :  #./runtest.py   path to test directory \n# Example :\n./runtest.py  ../ctests/gpio_toggle  The result should be  [OK]      gcc_compile\n[OK]      icarus_rtl_build\n[OK]      icarus_rtl_elab\n[OK]      icarus_rtl_sim  To see the commands used during the C compilation, the Verilog compilation and the simulation, add the option  -v  to the previous command line.  Viewing the waveform  First, the simulation must be launched with the -l option to turn-on the logging of all signals to a vcd file :  # Example :\n./runtest.py  -v -l ../ctests/gpio_toggle  Then  using gtkwave, you can open the vcd file that has been created in the directory of the test  tkwave ../ctests/gpio_toggle/tb_nanorv32.vcd", 
            "title": "Simulation  using Icarus iverilog"
        }, 
        {
            "location": "/#synthesis-using-vivado", 
            "text": "First, set-up Vivado environment :  source /opt/Xilinx/Vivado/ vivado version /settings64.sh  Then, in the  /synt/fpga directory, type :  make synt  Note : The code is loaded in the ROM using the file\nsynt/fpga/code.hex. So if you want to have a specific program preloaded, you must make a link between an existing *.hex2 file to the code.hex before launching the synthesis.  Important note : The reset pin in mapped to the SW0 switc on the ARTY7 board. The switch must be in the position toward the board center for the reset to be released.", 
            "title": "Synthesis using Vivado"
        }, 
        {
            "location": "/#uploading-code-using-the-jtag-port", 
            "text": "The Nanorv32 project includes a JTAG interface (implemented using the adv_debug_sys project) that allows new CPU code to be uploaded into the FPGA without the need of a new synthesis.  A python script for uploading code using a FT232H-based USB-to-JTAG converter is provided under  /jtag.  JTAG pin mapping for the Arty7 board  The JTAG pins are mapped on the JB connector (TCK is a special clock pin)     Pin  FPGA pin  Arty7 JB pin name  Arty7 JB pin number  FT232H pin      TMS  E15  P1  1  AD3 (16)    TDI  E16  P2  2  AD1 (14)    TCK  D15  P3  3  AD0 (13)    TDO  C15  P3  4  AD2 (15)     (P5 is GND and P6 is VCC on the JB 2x6 PMOD connector)  C Code compilation  The compilation of the C code to be uploaded is done using the same python script (runtest.py) as for the simulation.\nThe  .c  option must be used if you want to  prevent   the RTL database compilation and simulation.  # For example (while under  top /sim) :\n./runtest.py -c -v ../ctests/gpio_toggle_infinite  A Intel hex file is created under the test directory test  Code upload  The Intel hex file can be uploaded using the following command :  # Example (while under  top /sim) :\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/gpio_toggle_infinite/gpio_toggle_infinite.ihex -r  The  -r  option is used to force a reset after the code upload so that the CPU can start executing the code right away  The pyftdi and intelhex Python modules  may need to be installed for the comman above to work properly :  sudo pip install pyftdi intelhex", 
            "title": "Uploading code using the JTAG port"
        }, 
        {
            "location": "/#simulation-using-vivado-outdated", 
            "text": "Compilation  make xcomp\nmake xelab  Simulation (Batch mode)  make xsim  Simulation (GUI)  make xsim_gui", 
            "title": "Simulation  using Vivado (outdated)"
        }, 
        {
            "location": "/#simulation-using-verilator", 
            "text": "TBD", 
            "title": "Simulation  using Verilator"
        }
    ]
}